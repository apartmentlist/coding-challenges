#!/usr/bin/env ruby

INDENTATION = '  '.freeze

def usage
  puts <<~USAGE
    Usage: #{$0} file
    Interpret a Karel file and print the final state

    Example:
    % #{$0} move-up.krl
    location: (10, 10)
    direction: up
    tokens: [{"location":"(10, 0)","count":1},{"location":"(5, 5)","count":2}]
    operations: 42
  USAGE
end

Location = Struct.new(:x, :y) do
  def <=>(other)
    if x == other.x
      y <=> other.y
    else
      x <=> other.x
    end
  end
end

class Compass
  DIRECTIONS = {
    up: [0, 1],
    left: [-1, 0],
    down: [0, -1],
    right: [1, 0]
  }

  attr_reader :direction

  def initialize(direction)
    @direction = direction
  end

  def translate_location(location)
    Location.new(
      location.x + DIRECTIONS[direction][0],
      location.y + DIRECTIONS[direction][1]
    )
  end
end

class TokenContainer
  def initialize
    @tokens = {}
  end

  def any?(location)
    @tokens.key?(location)
  end

  def pick(location)
    if !@tokens.key?(location)
      fail "No tokens at #{location}"
    elsif @tokens[location] == 1
      @tokens.delete(location)
    else
      @tokens[location] -= 1
    end
  end

  def put(location)
    @tokens[location] ||= 0
    @tokens[location] += 1
  end

  def as_json
    @tokens.keys.sort.map do |location|
      {
        'location' => { 'x' => location.x, 'y' => location.y },
        'count' => @tokens[location]
      }
    end
  end
end

class Move
  def execute(compass, location, tokens)
    new_location = compass.translate_location(location)
    [nil, compass, new_location, tokens, 1]
  end
end

class Turn
  def execute(compass, location, tokens)
    dir_index = Compass::DIRECTIONS.keys.index(compass.direction)
    dir_index += 1
    dir_index %= 4
    new_compass = Compass.new(Compass::DIRECTIONS.keys[dir_index])
    [nil, new_compass, location, tokens, 1]
  end
end

class Token
  def execute(compass, location, tokens)
    [tokens.any?(location), compass, location, tokens, 1]
  end
end

class Pick
  def execute(compass, location, tokens)
    tokens.pick(location)
    [nil, compass, location, tokens, 1]
  end
end

class Put
  def execute(compass, location, tokens)
    tokens.put(location)
    [nil, compass, location, tokens, 1]
  end
end

class Not
  def initialize(statement)
    @statement = statement
  end

  def execute(compass, location, tokens)
    result, _, _, _, value = @statement.execute(compass, location, tokens)
    [!result, compass, location, tokens, value]
  end
end

class While
  def initialize(condition_statement)
    @condition_statement = condition_statement
    @statements = []
  end

  def add_statement(statement)
    @statements << statement
  end

  def execute(compass, location, tokens)
    result, _, _, _, value = @condition_statement.execute(compass, location, tokens)
    while result
      @statements.each do |statement|
        _, compass, location, tokens, v = statement.execute(compass, location, tokens)
        value += v
      end
      result, _, _, _, v = @condition_statement.execute(compass, location, tokens)
      value += v
    end
    [nil, compass, location, tokens, value]
  end
end

class If
  def initialize(condition_statement)
    @condition_statement = condition_statement
    @body_statements = []
    @else_statements = []
    @in_else = false
  end

  def else!
    raise ArgumentError, "unexpected else statement" if @in_else
    @in_else = true
  end

  def add_statement(statement)
    if @in_else
      @else_statements << statement
    else
      @body_statements << statement
    end
  end

  def execute(compass, location, tokens)
    result, _, _, _, value = @condition_statement.execute(compass, location, tokens)
    statements = result ? @body_statements : @else_statements
    statements.each do |statement|
      _, compass, location, tokens, v = statement.execute(compass, location, tokens)
      value += v
    end
    [nil, compass, location, tokens, value]
  end
end

class UserDefined
  attr_reader :name

  def initialize(name)
    @name = name
    @statements = []
  end

  def add_statement(statement)
    @statements << statement
  end

  def execute(compass, location, tokens)
    value = 0
    @statements.each do |statement|
      _, compass, location, tokens, v = statement.execute(compass, location, tokens)
      value += v
    end
    [nil, compass, location, tokens, value]
  end
end

class Program
  def initialize
    @statements = []
  end

  def add_statement(statement)
    @statements << statement
  end

  def execute(compass, location, tokens)
    value = 0
    @statements.each do |statement|
      _, compass, location, tokens, v = statement.execute(compass, location, tokens)
      value += v
    end
    [nil, compass, location, tokens, value]
  end
end

NATIVE_COMMANDS = {
  'move' => Move.new,
  'turn' => Turn.new,
  'on_token' => Token.new,
  'pick' => Pick.new,
  'put' => Put.new
}

def parse(file)
  commands = NATIVE_COMMANDS.dup
  stack = [Program.new]
  line_no = 0
  File.readlines(file).each do |raw_line|
    line = raw_line.chomp.gsub(/#.*/, '')
    line_no += 1
    curr_indent = INDENTATION * (stack.length - 1)
    udf_match = line.match(/^def ([\w]+)$/)
    if_match = line.match(/^#{curr_indent}if (\!)?([\w]+)$/)
    while_match = line.match(/^#{curr_indent}while (\!)?([\w]+)$/)
    command_match = line.match(/^#{curr_indent}([\w]+)$/)

    if udf_match
      if commands.key?(udf_match[1])
        raise SyntaxError, "Line #{line_no}: command '#{udf_match[1]}' is already defined"
      end
      stack.push(UserDefined.new(udf_match[1]))
    elsif if_match
      unless commands.key?(if_match[2])
        raise SyntaxError, "Line #{line_no}: command '#{if_match[2]}' not recognized"
      end
      command = commands[if_match[2]]
      condition = if_match[1] ? Not.new(command) : command
      stack.push(If.new(condition))
    elsif while_match
      unless commands.key?(while_match[2])
        raise SyntaxError, "Line #{line_no}: command '#{while_match[1]}' not recognized"
      end
      command = commands[while_match[2]]
      condition = while_match[1] ? Not.new(command) : command
      stack.push(While.new(condition))
    elsif command_match
      if commands.key?(command_match[1])
        stack.last.add_statement(commands[command_match[1]])
      else
        raise SyntaxError, "Line #{line_no}: command '#{command_match[1]}' not recognized"
      end
    elsif stack.length > 1
      prev_indent = INDENTATION * (stack.length - 2)
      if line.match(/^#{prev_indent}else$/)
        if stack.last.is_a?(If)
          begin
            stack.last.else!
          rescue ArgumentError => error
            raise SyntaxError, "Line #{line_no}: #{error.message}"
          end
        else
          raise SyntaxError, "Line #{line_no}: unexpected else statement"
        end
      elsif line.match(/^#{prev_indent}end$/)
        statement = stack.pop
        if statement.is_a?(UserDefined)
          commands[statement.name] = statement
        else
          stack.last.add_statement(statement)
        end
      else
        raise SyntaxError, "Line #{line_no}: command #{line} not recognized"
      end
    elsif line.strip != ''
      raise SyntaxError, "Line #{line_no}: command #{line} not recognized"
    end
  end
  stack.pop
end

def main(args)
  if args.length != 1
    usage
    exit(1)
  else
    program = parse(args.first)
    _, compass, location, tokens, value = program.execute(
      Compass.new(:up), Location.new(0, 0), TokenContainer.new
    )
    puts <<~STATE
      location: (#{location.x}, #{location.y})
      direction: #{compass.direction}
      tokens: #{tokens.as_json}
      operations: #{value}
    STATE
  end
rescue SyntaxError => error
  puts "Syntax error: #{error.message}"
  exit(2)
rescue RuntimeError => error
  puts "Run time error: #{error.message}"
  exit(1)
end

main(ARGV)
